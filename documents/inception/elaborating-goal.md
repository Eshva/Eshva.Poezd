# Проработка цели

Я хочу получить удобный способ написания приложений, построенных по Event-Driven Architecture, написанный преимущественно с использованием .NET. Я не хочу создавать фрейворк, который будет диктовать структуру и поведение приложения. Это скорее должно быть набором библиотек, которые позволяют упростить написание тех или иных компонентов приложения.

## Типичное EDA-приложение

В моём представлении, типичное EDA-приложение строится по следующей схеме. Приложение подписывается на те или иные сообщения, публикуемые в тех или иных очередях/топиках. При поступлении обрабатываемого типа сообщения находятся обработчики сообщения, которые затем инстанцируются и им на обработку передаётся полученное сообщение. Обработчики вносят те или иные изменения в состояние приложения. В процессе работы могут происходить и другие побочные эффекты, в частности публикуются другие сообщения: события об изменении состояния или команды другим сервисам.

Перед авторами приложений встают следующие вызовы:

* Как гарантировать доставку сообщения всем заинтересованным приложениям?
* Как гарантированно публиковать события о выполненном изменении состояния данного приложения?
* Как обработать сообщение единожды, если среда доставки реализована по принципу at least once?
* Как обеспечить обработку сообщений в последовательности их появления?
* Как упростить интеграцию между различными приложениями, использующими различные продукты для взаимодействия приложений по средствам асинхронных сообщений?
* Как соблюсти баланс между стабильностью контрактов взаимодействия и возможностью вносить изменения в приложение?
* Как не допустить или свести к минимуму vendor lock?
* Как упростить написание и поддержку приложения?

## Абстракция шины

В отличие от, скажем, Rebus, у меня нет цели обобщить в том числе суррогатные реализации шины сообщений через базы данных. Поддерживаться будет только абстракция продуктов, позволяющих приложениям обмениваться между собой по средствам асинхронных сообщений.

Главный фокус на Kafka, так как с помощью этого продукта можно достаточно легко реализовать гарантированную, хотя и evential, согласованность состояния в разных приложениях. Однако, должно быть возможным использовать и любые другие брокеры сообщений. 

## Dumb pipes and smart endpoints

Подобный подход позволяет не полагаться на шину с точки зрения маршрутизации сообщений, что встречается в довольно небольшом количестве подобных продуктов (брокеров сообщений, в широком понимании), а значит и иметь больше возможностей избежать vendor lock.

## Соответствие Clean Architecture

Эти библиотеки должны предоставлять правильные, с точки зрения Clean Architecture, способы интеграции, то есть зависимости должны быть направлены только в направлении от внешних слоёв к внутренним.

Что это значит? Обычно подобные библиотеки и фреймворки построены вокруг абстракции шины сообщений, которой пользуется код в слое приложения. Проблема состоит в том, что эта абстракция, например, `IBus`, определена в самой библиотеке. С точки зрения Clean Architecture, эта и связанные с ней абстракции должны быть определены в самом слое приложения, а библиотека должна реализовывать эту абстракцию, которая, по сути, являются частью слоя инфраструктуры. К этим абстракциям можно отнести:

* Классы сообщений: команды, события, запросы.
* Обработчики сообщений, в том числе process managers, sagas. Их будет вызывать реализация в слое инфраструктуры при получении обрабатываемых ими сообщений.
* Шина сообщений, позволяющая передать сообщения с использованием того или иного шаблона межсервисного взаимодействия.

## Цель

* Набор библиотек, эталонных реализаций и примеров для реализации EDA-приложений с максимально простой архитектурой, позволяющей обрабатывать сообщения и публиковать их, не заботясь о способах доставки сообщений и принципах поиска обработчика для полученного сообщения.
* Адаптеры для нескольких популярных брокеров сообщений.
* Адаптеры для нескольких популярных DI-контейнеров.
* Инфраструктура для написания unit, integration и end-to-end тестов.

# Реализация

## Общий алгоритм работы приложения

Приложение представляет собой набор обработчиков сообщений.

При старте приложения:

1. Приложение регистрирует в DI-контейнере все обработчики сообщений скопом.
2. Подписывальщик получает все типы сообщений из зарегистрированных DI-контейнере обработчиков.
3. Подписывальщик подписывается на получение данных типов сообщений в очередях/топиках, в соответствии с конфигурацией, описанной на инфраструктурном слое.

При поступлении обрабатываемого типа сообщения:

1. По типу сообщения и очереди/топику-источнику выбирается десериализатор.
2. Выбранный десериализатор используется для получения экземпляра сообщения.
3. Фабрика обработчиков создаёт экземпляры обработчиков, обрабатывающих данный тип сообщения.
4. Обработчикам передаётся экземпляр сообщения для обработки.
5. Обработчики обрабатывают сообщение и подтверждают обработку сообщения через абстракцию шины.

При публикации сообщения приложением:

1. Абстракция шины находит брокера сообщений и очередь/топик, который ответственен за передачу данного типа сообщений, в соответствии с конфигурацией приложения в инфраструктурном слое.
2. Абстракция шины вызывает соответствующий адаптер подключения к брокеру с целью передать сообщение в выбранную очередь/топик.
3. Абстракция шины информирует публикатора сообщения об успешной публикации сообщения или ошибки в её ходе.

## Составные части

* Библиотека эталонных контрактов слоя приложения: обработчик сообщения, process manager, bus. Пользователь библиотеки не должен быть принужден к использованию именно этой библиотеки и её абстракций, но должен либо скопировать их в своё приложение в виде файлов исходного кода, либо использовать свои, похожие на эталонные.
* Маршрутизатор сообщений к соответствующим обработчикам, реализованный в виде pipline, позволяющей фильтровать и обогащать сообщения.
* Контракт фабрики обработчиков по типу сообщений, а также его реализации для нескольких DI-контейнеров.
* Контракт адаптера брокера сообщений.
* Подписывальщик на сообщения в брокере сообщений.